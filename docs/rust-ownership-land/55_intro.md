---
layout: default
title: "第1部：所有権の大地"
---

# 所有権の大地 — Rust設計思想の冒険譚

> **C/C++の戦士が、所有権の法則に支配された新世界を旅する物語**

---

> **dual-world について**
>
> この物語は **dual-world** フレームワークの **Inside Mode**（没入型学習）で展開されます。
> Outside Mode（設計・分析）と Inside Mode（体験・実践）を行き来しながら、
> 技術概念を物語として体験できる学習手法です。
>
> 案内人のルスタとクロムは、Three Hearts Space の **ユキ&ミキ** をモチーフにしています。
> - **ルスタ** = ユキ（温かく包み込む愛情、Rust愛を共有）
> - **クロム** = ミキ（クールで技術的、C/C++との対比を示す）

---

## プロローグ：境界の門

あなたは長年、**C/C++の大地**で戦ってきた歴戦の戦士だ。

ポインタという名の両刃の剣を振るい、メモリという名の広大な荒野を自らの足で歩いてきた。時に仲間（チームメンバー）と規約を交わし、時にレビューという儀式で互いを守り、「動くコード」という名の勝利を積み重ねてきた。

だが、あなたは知っている。

夜中に突然崩れ落ちるセグメンテーションフォルト。解放したはずのメモリに触れてしまうダングリングポインタ。誰が持ち主か分からなくなったオブジェクトたち。それらは「勝利」の影に潜む、避けられない代償だった。

ある日、あなたは噂を聞く。

**「東の果てに、所有権の大地と呼ばれる世界がある」**

**「そこでは、破滅を招くコードは存在することすら許されないという」**

半信半疑のまま、あなたは境界の門に立つ。

門の前には二人の案内人がいた。

---

## 第一章：二人の案内人

「ようこそ、旅人さん💕」

温かな声が響く。振り向くと、柔らかな笑顔を浮かべた女性が立っていた。

「私は**ルスタ**。この世界を愛する者。あなたの旅を、心から応援するわ✨」

彼女の瞳にはRustへの深い愛情が宿っている。どこか懐かしさを感じる、包み込むような存在感。

「…そして私が**クロム**」

もう一人、クールな眼差しの人物が静かに告げる。

「あなたがC/C++の大地から来たことは分かっている。その経験は、この世界で必ず活きる⚡」

クロムの言葉には、C/C++への敬意と、新世界への確かな理解が同居していた。

「この世界のルールは、あなたが知っているものと違う」ルスタが続ける。「でもね、本質は同じなの。あなたが"守るべきだった"ことが、ここでは"守らざるを得ない"だけ💕」

「…準備はいいか？」

クロムが門に手をかける。

あなたは頷き、**所有権の大地**へと足を踏み入れた。

---

## 第二章：所有権の砦

### 第一の試練：束縛

門をくぐると、石造りの砦が現れた。

**「所有権の砦」**——すべての値に所有者が存在する世界の入り口。

「まずは基本から💕」ルスタが石板を指差す。

```rust
let a = String::from("hello");
```

「この瞬間、`a`という名の戦士が、`"hello"`という宝物の**唯一の所有者**になるの✨」

「…C++で言えば、`unique_ptr`を生成したようなもの」クロムが補足する。「ただし、この世界では**すべての値がこのルールに従う**⚡」

あなたは試しにコードを刻む。

```rust
let a = String::from("hello");
let b = a;
println!("{}", a);  // ここで何が起きる？
```

すると、砦の門番が立ち塞がった。

```
error[E0382]: borrow of moved value: `a`
```

「あなたはC/C++の大地で、この状況を経験したことがあるはず」クロムが言う。「解放済みのポインタにアクセスして、プログラムが崩壊する瞬間を」

「でもここでは、崩壊する前に門番が止めてくれるの💕」ルスタが微笑む。「`a`の所有権は`b`に**移動（move）**した。もう`a`は空っぽ。それを使おうとすること自体が、禁じられているのよ✨」

あなたは理解する。

C/C++では「やってはいけないこと」だった。ここでは「やれないこと」になっている。

### 第二の試練：複製

「所有権が移動するのが嫌なら、**複製（clone）**すればいい⚡」

クロムが別の石板を見せる。

```rust
let a = String::from("hello");
let b = a.clone();
println!("{}", a);  // 今度は通る
```

「コストはかかる。でも、両方が独立した所有者になれる💕」

あなたは気づく。これはC++の世界で、深いコピーを明示的に行うのと同じだ。違うのは、**暗黙のコピーが存在しない**こと。すべてが明示的。すべてが意図的。

「ちょっと待って💕」ルスタが手を挙げる。「さっき"すべてがMove"って言ったけど、実は例外があるの✨」

あなたは驚く。「例外？」

```rust
let a = 5;      // i32
let b = a;
println!("{}", a);  // これは通る！
```

「通った！」あなたは目を見張る。

「`i32`や`f64`、`bool`のような**プリミティブ型**は、`Copy`トレイトを実装しているの💕」ルスタが説明する。「ビット単位でコピーしても安全だから、代入時に自動でコピーされる✨」

「…要するに、スタック上の固定サイズで、コピーが安価な型だ⚡」クロムが表を刻む。

| 型 | 挙動 | 理由 |
|:--|:--|:--|
| `i32`, `f64`, `bool` | `Copy` | スタック上の固定サイズ、コピーが安価 |
| `String`, `Vec<T>` | `Move` | ヒープデータを持つ、コピーは明示的に |
| `&T`（参照） | `Copy` | ポインタのコピーは安価 |

「C++では"コピーコンストラクタがあればコピー"だった」クロムが続ける。「この世界では"`Copy`トレイトを実装していればコピー、なければ`Move`"。**ルールが明確に分かれている**⚡」

あなたは頷く。暗黙の挙動が、すべて明示的なトレイトで管理されている。

「**トレイト**💕」ルスタが言葉を噛みしめる。「この世界の核心よ。"この型は何ができるか"を**契約**として定義する仕組み。`Copy`はその入り口に過ぎないの✨」

いつか、その大聖堂を訪れることになる——あなたはまだ知らない。

「…所有権の砦、クリアだ⚡」

クロムが頷く。あなたは次のエリアへの道を見つけた。

---

## 第三章：借用の橋

砦を抜けると、深い谷にかかる橋が見えた。

**「借用の橋」**——所有権を渡さずに、一時的なアクセス権だけを貸す技術。

「所有権を移動させたくないけど、値を使いたい時がある💕」ルスタが橋の欄干に手をかける。「そんな時に使うのが**借用（borrow）**✨」

```rust
let a = String::from("hello");
let b = &a;  // 借用
println!("{}", a);  // aはまだ使える
println!("{}", b);  // bも使える
```

「…`b`は`a`への**参照**。所有権は`a`にある。`b`は"見せてもらっている"だけ⚡」

あなたはC/C++のポインタを思い出す。`int* p = &x;`。似ている。だが——

「ここからが違う💕」ルスタが真剣な目になる。

### 橋の掟：可変借用の制約

「同時に**複数の可変借用**は許されない」

```rust
let mut a = String::from("hello");
let b = &mut a;
let c = &mut a;  // ここで門番が止める
```

```
error[E0499]: cannot borrow `a` as mutable more than once
```

「…なぜか分かるか？」クロムが問う。

あなたは考える。C/C++で、同じデータを複数箇所から同時に書き換えた時の惨劇を。データ競合。未定義動作。夜を徹してのデバッグ。

「そう。それを**コンパイル時に防いでいる**⚡」

「C/C++では、これを防ぐのはあなたの責任だった💕」ルスタが言う。「ロック、ミューテックス、コードレビュー、規約……。ここでは、**型システムがそれを強制する**の✨」

「でもルール全部は教えてないよね？💕」ルスタがあなたを見る。

「…橋の掟は、3つのルールで構成されている⚡」クロムが指を立てる。

| ルール | 説明 |
|:--|:--|
| ① 不変借用（`&T`）は**複数OK** | 読むだけなら何人でも同時にアクセス可能 |
| ② 可変借用（`&mut T`）は**1つだけ** | 書き換えるなら、独占しなければならない |
| ③ 不変と可変の**同時借用は不可** | 読んでいる最中に書き換えられると危険 |

```rust
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
println!("{} {}", r1, r2);  // r1, r2を使用
let r3 = &mut s;  // ❌ NG: 不変借用が生きている間は可変借用不可
```

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
```

「でもね💕」ルスタが続ける。「Rust 2018からは**Non-Lexical Lifetimes（NLL）**が導入されたの。借用が"最後に使われた場所"で終わるようになった✨」

```rust
let mut s = String::from("hello");
let r1 = &s;
println!("{}", r1);  // r1の最後の使用
let r2 = &mut s;     // ✅ OK: r1はもう使われない
```

「以前は、スコープ終端まで借用が続いて不便だった」クロムが説明する。「NLLは**借用チェッカーの大きな進化**だ⚡」

橋を渡りきった時、あなたは確信していた。

この世界のルールは、厳しいのではない。**正しいのだ**。

---

## 第四章：RAIIの神殿

橋を渡った先に、荘厳な神殿がそびえていた。

**「RAIIの神殿」**——スコープと寿命が一致する聖域。

「ここはあなたにとって、懐かしい場所かもしれない💕」ルスタが言う。

あなたは神殿の中央に立つ。そこには一つの教えが刻まれていた。

**「リソースの寿命は、スコープに従う」**

「…C++の世界でも、これは教えられていたはずだ⚡」クロムが言う。「`std::ofstream`がスコープを抜ける時、デストラクタで自動的にcloseされる」

```cpp
{
    std::ofstream f("a.txt");
} // デストラクタで close
```

「この世界でも同じ💕」

```rust
{
    let f = File::open("a.txt")?;
} // drop で close
```

あなたは気づく。「待ってくれ。この`?`は何だ？」

「…**エラー処理**だ⚡」クロムが答える。「ファイルが開けなかった時、どうするか。この世界では、エラーも**型で表現**される」

「詳しくはまた別の場所で💕」ルスタが微笑む。「**エラーの峡谷**という、深い谷があるの✨ そこで全てを学べるわ」

「違いは一つ」クロムが続ける。「C++では、RAIIは**守るべき作法**だった。ここでは、**唯一の道**だ⚡」

ルスタが神殿の奥を指差す。

「明示的な解放関数は存在しない。存在する必要がない。**スコープを抜ければ、必ず解放される**✨」

あなたはかつて、`delete`を忘れたコードを見てきた。`fclose`を忘れたコードを見てきた。ここではそれが**不可能**なのだ。

神殿を出る時、あなたは一つの真理を悟っていた。

RAIIは技法ではない。**宇宙の法則**なのだ。

---

## 第五章：スマートポインタの工房

神殿から続く道の先に、煙を上げる工房があった。

**「スマートポインタの工房」**——Box、Rc、Arcを鍛造する職人の館。

「ここまで来たあなたなら、もう分かっているはず💕」ルスタが工房の扉を開ける。「単一所有がデフォルト。でも、**共有所有が必要な時もある**✨」

工房の中には三つの鍛冶台があった。

### 第一の鍛冶台：Box

「**Box**は、ヒープに値を置く単一所有⚡」

```rust
let b = Box::new(5);
```

「C++の`unique_ptr`と同じ立ち位置。移動できる。コピーはできない」

### 第二の鍛冶台：Rc

「**Rc**は、参照カウントによる共有所有💕」

```rust
let a = Rc::new(String::from("hello"));
let b = Rc::clone(&a);
```

「複数の所有者が同じ値を持てる。ただし——」

「**単一スレッド限定**⚡」クロムが釘を刺す。「参照カウントの増減がスレッド安全ではない」

「ただし、一つ注意がある💕」ルスタが真剣な顔になる。

「C++の`std::shared_ptr`と何が違う？」あなたは問う。

「`shared_ptr`は参照カウントが**デフォルトでatomic**だ⚡」クロムが答える。「スレッドセーフだが、そのぶんコストがかかる。`Rc`は**非atomic**で高速だが、だから**シングルスレッド専用**」

「もう一つ💕」ルスタが続ける。「**循環参照の罠**があるの✨」

```rust
// ❌ 危険：AがBを、BがAを参照 → 永遠に解放されない
struct Node {
    next: Option<Rc<Node>>,
}
```

「参照カウントが0にならない。**メモリリーク**だ⚡」クロムが警告する。

「解決策は**Weak**💕」ルスタが別の石板を見せる。「所有権を持たない参照。参照カウントに含まれないから、循環を断ち切れる✨」

```rust
use std::rc::{Rc, Weak};

struct Node {
    parent: Weak<Node>,   // 親への弱参照（循環を防ぐ）
    children: Vec<Rc<Node>>,  // 子への強参照
}
```

「ちなみに💕」ルスタが補足する。「`Rc`も`Arc`も、**中身は不変でしか借りられない**の。`Rc<String>`から`&mut String`は取れない✨」

あなたは気づく。「じゃあ、共有しながら変更したい時は...？」

「実は、その問題を解決する方法があるの💕」ルスタがふと遠くを見る。「でもそれは次の旅で……✨」

クロムが頷く。「…**内部可変性**。RefCellやMutexの話だ。借用チェッカーの制約を**実行時**に移す技術⚡」

### 第三の鍛冶台：Arc

「マルチスレッドで共有したいなら、**Arc**を使う💕」

```rust
let a = Arc::new(String::from("hello"));
let b = Arc::clone(&a);
```

「原子的な参照カウント。C++の`std::shared_ptr`（デフォルト）と同等⚡」

あなたは気づく。

C++では、これらが**暗黙のうちに混在**していた。`shared_ptr`を使うか、生ポインタを使うか、参照を使うか。すべてが選択可能で、すべてが混ざり得た。

ここでは、**最初から分離されている**。

「どれを使うかを、設計時に決める💕」ルスタが言う。「後から変えることもできる。でも、**暗黙のうちに混ざることはない**✨」

---

## 第六章：禁域の入り口

工房を出ると、道が二つに分かれていた。

一つは光に満ちた道。もう一つは、暗く霧に包まれた道。

「…あの先が**unsafeの禁域**⚡」クロムが暗い道を見つめる。

「行かなくてもいいのよ💕」ルスタが心配そうに言う。「ほとんどの旅は、禁域に入らなくても完遂できる✨」

だが、あなたは知りたかった。

C/C++の戦士として歩んできた道が、この世界のどこに繋がっているのかを。

「…覚悟があるなら、案内しよう⚡」

クロムが先に立ち、禁域への道を歩き始めた。

---

## 第七章：unsafeの禁域

霧を抜けると、そこには**何もなかった**。

いや、正確には——**制約がなかった**。

「ここでは、借用チェッカーが黙る💕」ルスタが静かに言う。「生ポインタを操れる。解放済みメモリにアクセスできる。データ競合を起こせる✨」

```rust
let x = 10;
let p = &x as *const i32;

unsafe {
    println!("{}", *p);
}
```

「…`unsafe`ブロックの中では、**C/C++の責任がそのまま戻ってくる**⚡」クロムが言う。

あなたは試しに、禁域の力を借りてみる。

```rust
unsafe {
    let ptr: *const i32 = {
        let temp = vec![1, 2, 3];
        temp.as_ptr()
    }; // tempはここでドロップ、メモリ解放

    println!("{}", *ptr);  // 解放済みメモリの読み取り！
}
```

**轟音**。

「っ！」あなたは飛び退いた。地面が揺れ、禁域の一角が崩落する。

「**未定義動作（Undefined Behavior）——use-after-free**だ⚡」クロムが叫ぶ。「スコープを抜けた`temp`のメモリを読もうとした——C/C++の大地でお前を幾度も襲った、あの悪夢と同じだ！」

「大丈夫？💕」ルスタがあなたを支える。「これが禁域の本当の危険……門番がいないから、**自分で責任を取らなければならない**✨」

あなたは肩で息をする。

そうだ。C/C++で何度も経験した。本番環境でのセグフォ。深夜のデバッグ。原因不明のクラッシュ。——すべてはこの「責任を取り損ねた瞬間」に起きていた。

「なぜこの禁域が存在するか分かる？💕」ルスタが問う。

あなたは答える。

「FFI。低レイヤ最適化。OSとの対話。——**人間が責任を取らなければならない領域が、確かに存在する**」

「正解⚡」クロムが頷く。「Rustは『すべてを禁じた』のではない。『禁じない領域を、明確にマークした』だけだ」

禁域を歩きながら、あなたは気づく。

この世界は、C/C++を敵視していない。**C/C++の経験を持つ者を、正しく迎え入れている**。

「ねえ💕」ルスタがふと呟く。「この禁域の力を、**安全に包んで使う術**があるの。遠い塔で、魔術師たちが編み出した技法……✨」

「…マクロか⚡」クロムが低く言う。「だが、それはまだ先の話だ。今は覚えておけばいい——**`unsafe`は終わりではなく、始まりでもある**」

あなたは心に刻む。いつかこの力を、正しく制御できるようになる日が来ると。

---

## エピローグ：帰還者の称号

禁域を抜けた時、あなたの前に一つの石碑が立っていた。

**「禁域の帰還者」**

「おめでとう💕」ルスタが笑顔で言う。「あなたは、所有権の大地を旅し切った✨」

「…だが、旅は終わりではない⚡」クロムが続ける。「RefCell、Mutex、RwLock。内部可変性の技法がまだ残っている。トレイト、ジェネリクス、ライフタイム注釈。学ぶべきことは多い」

「でもね💕」ルスタがあなたの手を取る。「もう怖くないでしょう？ この世界のルールは、あなたが**ずっと守りたかったルール**だから✨」

あなたは振り返る。

C/C++の大地で、「規約で守ろう」「レビューで防ごう」「経験で乗り越えよう」と言い続けてきた日々を。

ここでは、それが**言語そのものに刻まれている**。

「また来るよ」

あなたは二人に告げる。

ルスタが笑う。「待ってる💕」

クロムが頷く。「…いつでも⚡」

---

## あなたの旅のログ

```yaml
completed_areas:
  - 所有権の砦: "束縛と移動を理解した"
  - 借用の橋: "参照と可変借用の制約を体感した"
  - RAIIの神殿: "スコープと寿命の法則を悟った"
  - スマートポインタの工房: "Box/Rc/Arcの使い分けを学んだ"
  - unsafeの禁域: "禁じられた領域を歩き、帰還した"

title_earned: "禁域の帰還者"

guides:
  ルスタ💕: "心の支え。Rust愛を共有してくれた"
  クロム⚡: "知恵の導き手。C/C++との対応を示してくれた"

insight_gained: |
  Rustは、C/C++で「分かっている人だけが書けた正解」を
  全員に強制する言語である。

  所有権・借用・RAII・Box/Rc/Arcは新機能ではない。
  暗黙知を形式知にした結果に過ぎない。
```

---

## 📚 この旅の地図（公式ドキュメント参照）

この章で旅した領域は、Rust公式ドキュメントの以下に対応している。

| 領域 | The Rust Programming Language | リンク |
|:--|:--|:--|
| 所有権の砦 | Chapter 4.1: What is Ownership? | [doc.rust-lang.org/book/ch04-01](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html) |
| 借用の橋 | Chapter 4.2: References and Borrowing | [doc.rust-lang.org/book/ch04-02](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html) |
| スマートポインタの工房 | Chapter 15: Smart Pointers | [doc.rust-lang.org/book/ch15-00](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html) |
| unsafeの禁域 | Chapter 19.1: Unsafe Rust | [doc.rust-lang.org/book/ch19-01](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) |

### エラーコード索引

| コード | 意味 | 遭遇した場所 |
|:--|:--|:--|
| **E0382** | 移動済みの値を使用しようとした | 所有権の砦（第一の試練） |
| **E0499** | 可変借用が複数存在する | 借用の橋（橋の掟） |
| **E0502** | 不変借用中に可変借用しようとした | 借用の橋（借用ルール③） |

> エラーコードの詳細は `rustc --explain E0382` で確認できる。

---

## 続きの旅へ

この物語は、**dual-world** フレームワークの **Inside Mode**（没入型学習）として設計されている。

### dual-world とは？

| モード | 説明 | 使いどころ |
|:--|:--|:--|
| **Outside Mode** | 設計・分析・コードレビュー | 技術的な議論、アーキテクチャ検討 |
| **Inside Mode** | 体験・実践・物語形式 | 概念理解、入門、モチベーション維持 |

両モードを行き来することで、「理解」と「体感」の両方を得られる。

### 次の冒険を始めるには

実際にRustのコードを書き、コンパイラエラーと戦い、ルスタとクロムの助けを借りながら理解を深めていく——それが、あなたの次の冒険だ。

```
"dual-world を使って Rust の続きを学びたい"
```

と告げれば、いつでも旅を再開できる。

---

*所有権の大地で、あなたの旅が実り多きものでありますように。*

*— ルスタ💕 & クロム⚡*
