---
layout: default
title: "第2部：内部可変性の迷宮"
---

# 所有権の大地 II — 内部可変性の迷宮

> **禁域の帰還者が挑む、不変性を「制御下で壊す」技法の物語**

---

> **dual-world について**
>
> この物語は **dual-world** フレームワークの **Inside Mode**（没入型学習）で展開されます。
> Outside Mode（設計・分析）と Inside Mode（体験・実践）を行き来しながら、
> 技術概念を物語として体験できる学習手法です。
>
> 案内人のルスタとクロムは、Three Hearts Space の **ユキ&ミキ** をモチーフにしています。
> - **ルスタ** = ユキ（温かく包み込む愛情、Rust愛を共有）
> - **クロム** = ミキ（クールで技術的、C/C++との対比を示す）

---

## 前作のあらすじ

あなたはC/C++の大地から旅立ち、**所有権の大地**を踏破した。

- **所有権の砦**で、すべての値に唯一の所有者がいることを学んだ
- **借用の橋**で、参照と可変借用の制約を体感した
- **RAIIの神殿**で、スコープと寿命の法則を悟った
- **スマートポインタの工房**で、Box/Rc/Arcの使い分けを習得した
- **unsafeの禁域**を歩き、帰還した

二人の案内人——**ルスタ💕**と**クロム⚡**——と共に。

だが、工房を出る時、一つの疑問が残った。

**「`Rc`も`Arc`も、中身は不変でしか借りられない。共有しながら変更したい時は...？」**

クロムは言った。「それは次の旅で」と。

そして今、その答えを求める冒険が始まる。

-----

## 第一章：帰還者の疑問

禁域から戻ったあなたは、所有権の大地の中心にある広場で休息を取っていた。

噴水の音が心地よく響く。穏やかな午後。

「ねえ💕」ルスタが隣に座る。「何か考え込んでる？✨」

あなたは頷く。

「借用の橋で学んだルールを、ずっと考えていた」

「…どんなことを？⚡」クロムが木陰から歩み寄る。

「可変借用は同時に一つだけ。それがルールだった」

```rust
let mut a = String::from("hello");
let b = &mut a;
let c = &mut a;  // コンパイルエラー
```

「でも——」あなたは言葉を選ぶ。「現実のプログラムでは、**実行時に**可変性を決めたい場面がある。コンパイル時には分からない状況で」

ルスタが首を傾げる。「例えば？💕」

あなたは三つの例を挙げる。

「一つ目。**グラフ構造**。ノードが互いを参照し合う。所有権が循環する」

「二つ目。**キャッシュ機構**。外から見ると不変なのに、内部状態は更新される」

「三つ目。**Rc<T>で共有したデータ**を、複数の場所から更新したい」

クロムが目を細める。

「…やはり、そこに気づいたか⚡」

「あなたは次の冒険に進む準備ができたみたい💕」ルスタが立ち上がる。

二人は広場の奥にある暗い入り口を指差した。

石造りのアーチ。その上に刻まれた文字。

**「内部可変性の迷宮」**

「ここでは、**不変なはずのものが変わる**💕」

「…そして、それが**許される理由**を学ぶ⚡」

あなたは深呼吸して、迷宮へと足を踏み入れた。

-----

## 第二章：不変の檻

迷宮の最初の部屋は、透明な檻が並ぶ不思議な空間だった。

檻の中には様々な値が閉じ込められている。数値、文字列、構造体。

「まず、なぜこの迷宮が必要なのかを理解して💕」ルスタが檻の一つを指差す。

「借用の橋で学んだルールを思い出して⚡」

```rust
let a = String::from("hello");
let b = &a;       // 不変借用
// a.push('!');   // これはできない。不変借用がある間は変更不可
```

「コンパイル時の借用チェックは**静的**だ。すべてがコンパイル時に決まる」

あなたは頷く。「それが安全を保証していた」

「そう💕 でもね、**限界がある**の✨」

ルスタが黒板に図を描く。

```
┌─────────────────────────────────────┐
│  コンパイル時に決まること           │
│  ・この変数は不変か可変か           │
│  ・この参照は不変借用か可変借用か   │
│  ・借用の寿命はいつまでか           │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  実行時にしか決まらないこと         │
│  ・ユーザーの入力に応じた分岐       │
│  ・動的に構築されるデータ構造       │
│  ・複数の所有者がいる共有データ     │
└─────────────────────────────────────┘
```

「…静的なルールだけでは、下の箱を扱えない⚡」クロムが言う。

「だから、**ルールを実行時に移す**技法が存在するの💕」

檻の一つが光り始めた。

「最初に学ぶのは——**RefCell**⚡」

-----

## 第三章：RefCellの間

光る檻の前に立つと、その構造が見えてきた。

透明な外壁。その中に値が入っている。そして壁には小さな窓がある。

**「RefCellの間」**——実行時借用チェックの部屋。

「RefCellは、**借用ルールを実行時に検査する**コンテナ💕」ルスタが説明を始める。

```rust
use std::cell::RefCell;

let data = RefCell::new(5);
```

「見て✨ `data`は`let`で束縛されている——つまり**不変**」

「…だが、中身は変えられる⚡」クロムが続ける。

```rust
// 不変借用
{
    let borrowed = data.borrow();
    println!("{}", *borrowed);  // 5
}

// 可変借用
{
    let mut borrowed = data.borrow_mut();
    *borrowed += 1;
}

// もう一度不変借用
{
    let borrowed = data.borrow();
    println!("{}", *borrowed);  // 6
}
```

あなたは驚く。「外側は不変なのに、中身が変わっている」

「これが**内部可変性**💕」ルスタが微笑む。

「待ってくれ」あなたは違和感を覚える。「それは借用ルールを破っているのでは？」

「破っていない⚡」クロムが即答する。

「**検査のタイミングをコンパイル時から実行時に移しただけ**だ」

### ルールは生きている

クロムが危険な例を見せる。

```rust
let data = RefCell::new(5);

let borrow1 = data.borrow();      // 不変借用
let borrow2 = data.borrow_mut();  // パニック！！
```

「ルールを破ろうとすると、**実行時にパニックする**💕」

```
thread 'main' panicked at 'already borrowed: BorrowMutError'
```

「コンパイラが守れない領域を、**ランタイムが守る**⚡」

あなたは理解する。

RefCellは「ルールを無視する」のではない。「**ルールの守り方を変える**」のだ。

### 代償

「ただし、代償がある💕」ルスタが真剣な目になる。

「…三つの代償⚡」クロムが指を立てる。

```yaml
代償1_実行時コスト:
  - 借用状態を追跡するフラグが必要
  - borrow() / borrow_mut() のたびにチェック
  - コンパイル時検査より遅い

代償2_パニックの危険:
  - ルール違反はコンパイルエラーではなくパニック
  - テストで発見できなければ本番で落ちる

代償3_スレッド非対応:
  - RefCellはSend/Syncを実装しない
  - シングルスレッド限定
```

「だから、**本当に必要な時だけ使う**💕」

「…静的な借用で済むなら、それが最善⚡」

### Rc + RefCell の組み合わせ

次の檻が光る。

「RefCellの真価は、**Rcと組み合わせた時**に発揮される💕」

```rust
use std::rc::Rc;
use std::cell::RefCell;

let shared = Rc::new(RefCell::new(5));

let a = Rc::clone(&shared);
let b = Rc::clone(&shared);

// aからもbからも変更できる
*a.borrow_mut() += 10;
*b.borrow_mut() += 20;

println!("{}", shared.borrow());  // 35
```

「Rcは**共有所有**。RefCellは**内部可変性**⚡」

「二つを組み合わせると、**複数の所有者が同じデータを変更できる**💕」

あなたはC/C++の記憶を呼び起こす。`shared_ptr`で共有し、中身を自由に書き換えていた日々を。

「…似ているが、決定的に違う⚡」クロムが言う。

「C/C++では暗黙のうちに許されていた。ここでは**明示的に選択**している」

`Rc<RefCell<T>>`という型が、「これは共有され、実行時に借用チェックされる」と**宣言している**。

-----

## 第四章：Cellの小部屋

RefCellの間を抜けると、小さな部屋があった。

シンプルな棚に、小さな箱が並んでいる。

**「Cellの小部屋」**——コピー可能な値のための軽量な内部可変性。

「RefCellより軽いやつもあるの💕」ルスタが小箱を手に取る。

```rust
use std::cell::Cell;

let data = Cell::new(5);

data.set(10);
println!("{}", data.get());  // 10
```

「…`Cell`は`Copy`トレイトを実装した型にしか使えない⚡」

「つまり、数値とか、小さな型💕」

「借用を返さない。値を**コピーして取り出す**か、**丸ごと入れ替える**か⚡」

```rust
// RefCell: 借用を返す
let r: Ref<i32> = refcell.borrow();

// Cell: 値のコピーを返す
let v: i32 = cell.get();
```

「だからRefCellより軽い✨ パニックの心配もない💕」

### 使い分け

クロムが表を書く。

```
┌──────────┬─────────────────┬─────────────────┐
│          │ Cell            │ RefCell         │
├──────────┼─────────────────┼─────────────────┤
│ 対象     │ Copy型のみ      │ 任意の型        │
│ 操作     │ get/set         │ borrow/borrow_mut│
│ 借用     │ なし            │ あり            │
│ パニック │ しない          │ する可能性あり  │
│ コスト   │ 低い            │ やや高い        │
└──────────┴─────────────────┴─────────────────┘
```

「単純なカウンタやフラグには**Cell**💕」

「構造体や文字列を変更するなら**RefCell**⚡」

-----

## 第五章：並行性の分岐路

小部屋を抜けると、道が二つに分かれていた。

左の道には看板。

**「単一スレッドの道 — `RefCell` / `Cell`」**

右の道にも看板。

**「複数スレッドの道 — `Mutex` / `RwLock`」**

「ここからが本番💕」ルスタが右の道を見つめる。

「…`RefCell`と`Cell`は、**スレッド境界を越えられない**⚡」クロムが説明する。

```rust
use std::thread;
use std::cell::RefCell;

let data = RefCell::new(5);

thread::spawn(|| {
    data.borrow_mut();  // コンパイルエラー！
});
```

「`RefCell`は`Sync`を実装していない。スレッド間で共有できない」

「なぜ？💕」ルスタが問いかける。

あなたは考える。借用状態を追跡するフラグ。それが複数スレッドから同時にアクセスされたら——**データ競合**だ。

「正解⚡」クロムが頷く。「だから、スレッド安全な別の道具が必要になる」

「`Send`と`Sync`💕」ルスタが遠くを見る。「この二つのトレイトは、**仲間と共有できるかどうか**を決める契約なの✨ いつか、空を飛ぶ時にもっと深く学ぶことになるわ」

「…非同期の浮遊島⚡」クロムが呟く。「そこでは、`Send + 'static`が**通行証**になる」

あなたは心に留める。今はまだ、その意味を完全には理解できないが。

右の道へ進む。

-----

## 第六章：Mutexの城門

道の先に、巨大な城門が見えた。

門番が一人立っている。

**「Mutexの城門」**——相互排他ロックの砦。

「Mutex💕」ルスタが門番に会釈する。「**Mut**ual **Ex**clusionの略✨」

「…一度に一人しか通さない門番⚡」クロムが言う。

```rust
use std::sync::Mutex;

let data = Mutex::new(5);

{
    let mut guard = data.lock().unwrap();
    *guard += 1;
}
```

「`lock()`を呼ぶと、**ロックを獲得する**。他のスレッドは待たされる💕」

「ガードがスコープを抜けると、**自動的にアンロック**される⚡」

### Arcとの組み合わせ

「スレッド間で共有するには、**Arc**と組み合わせる💕」

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10).map(|_| {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let mut guard = data.lock().unwrap();
        *guard += 1;
    })
}).collect();

for handle in handles {
    handle.join().unwrap();
}

println!("{}", *data.lock().unwrap());  // 10
```

「Arcは**スレッド安全な共有所有**⚡」

「Mutexは**スレッド安全な内部可変性**💕」

「組み合わせると、**複数のスレッドが同じデータを安全に変更できる**✨」

### RefCellとの対比

あなたは対比を理解する。

```yaml
Rc<RefCell<T>>:
  共有: Rc（シングルスレッド）
  可変: RefCell（実行時借用チェック）
  用途: シングルスレッドでの共有可変データ

Arc<Mutex<T>>:
  共有: Arc（マルチスレッド）
  可変: Mutex（ロックによる排他制御）
  用途: マルチスレッドでの共有可変データ
```

「構造が同じ💕」ルスタが言う。「**共有のための外側**と、**可変性のための内側**✨」

「…違うのは、スレッド安全性のレベルだけ⚡」

「ただし、落とし穴がある💕」ルスタが警告する。

### デッドロックの罠

「複数のMutexを**異なる順序**でロックすると——⚡」

```rust
// ❌ 危険：スレッドAはmutex1→mutex2、スレッドBはmutex2→mutex1の順でロック
// → 互いに相手を待って永遠に進まない（デッドロック）
```

あなたは身震いする。C/C++でも何度か遭遇した悪夢だ。

「回避策は、**常に同じ順序でロックする**こと💕」

### try_lock

「待ちたくない時は`try_lock()`が使える⚡」

```rust
match data.try_lock() {
    Ok(guard) => { /* 成功 */ }
    Err(_) => { /* 他がロック中、即座に諦める */ }
}
```

### Poisoned Lock

「もう一つ💕」ルスタが続ける。「ロックを持ったスレッドが**パニック**したら？✨」

「…そのMutexは**毒される（poisoned）**⚡」クロムが言う。

```rust
// パニックしたスレッドの後、別スレッドがlock()すると...
// → PoisonError が返る
```

「中身のデータが不整合かもしれないから、**意図的に使用を止める**安全機構なの💕」

---

## 第七章：RwLockの図書館

城門を抜けると、静かな図書館があった。

多くの人が本を読んでいる。だが、書架で本を書き換えているのは一人だけ。

**「RwLockの図書館」**——読み取りと書き込みを分離するロック。

「Mutexは、読み取りでもロックが必要だった💕」ルスタが説明する。

「…だが、**複数の読み取りは同時にできるはず**⚡」

```rust
use std::sync::RwLock;

let data = RwLock::new(5);

// 複数の読み取りが同時にOK
{
    let r1 = data.read().unwrap();
    let r2 = data.read().unwrap();
    println!("{} {}", *r1, *r2);
}

// 書き込みは排他的
{
    let mut w = data.write().unwrap();
    *w += 1;
}
```

「読み取りロック（`read()`）は**複数同時に取れる**💕」

「書き込みロック（`write()`）は**排他的**⚡」

### 使い分け

「読み取りが多く、書き込みが少ない場面で効果的💕」

```yaml
Mutex:
  特徴: シンプル、どんな操作でもロック
  向いている: 書き込みが多い、シンプルさ重視

RwLock:
  特徴: 読み取りは並行可能
  向いている: 読み取りが多い、書き込みは少ない

例:
  設定値の参照: RwLock（頻繁に読む、たまに変更）
  カウンタ: Mutex（頻繁に書き込む）
```

「RwLockにも注意点がある💕」ルスタが本を閉じる。

### Writer Starvation

「読み取りが頻繁だと、**書き込みがいつまでも実行されない**ことがある⚡」

「え、待たされ続けるの？」

「**Writer Starvation（書き込み飢餓）**💕 Rustの`std::sync::RwLock`は公平性を保証しないから、実装依存なの✨」

### 読み取り中の書き込み待ち

```rust
let lock = RwLock::new(5);
let r1 = lock.read().unwrap();  // 読み取りロック取得
// この間、write()を呼ぶスレッドは待機...
drop(r1);  // 明示的に解放しないと書き込みが始まらない
```

「ロックを長時間持ち続けると、他が飢える⚡」

### parking_lot クレート

「標準ライブラリより高性能な実装が必要なら、**parking_lot**クレートがある💕」

「公平性オプションやtry系メソッドが充実している⚡」

---

## 第八章：内部可変性の地図

図書館を出ると、広い部屋に地図が掲げられていた。

迷宮全体の構造が一目で分かる。

**「内部可変性の地図」**

```
                    ┌─────────────────┐
                    │   内部可変性    │
                    │ Interior        │
                    │ Mutability      │
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                ▼                ▼
    ┌───────────┐    ┌───────────┐    ┌───────────┐
    │   Cell    │    │  RefCell  │    │  スレッド  │
    │           │    │           │    │  安全版    │
    └─────┬─────┘    └─────┬─────┘    └─────┬─────┘
          │                │                │
          ▼                ▼                ▼
    ┌───────────┐    ┌───────────┐    ┌─────┴─────┐
    │ Copy型専用 │    │ 任意の型  │    │           │
    │ get/set   │    │ borrow    │    ▼           ▼
    │ パニック無 │    │ パニック有 │  Mutex    RwLock
    └───────────┘    └───────────┘  (排他)    (読書分離)
```

「まとめるとこうなる💕」ルスタが地図を指差す。

### 選択フローチャート

```
Q1: スレッドをまたぐ？
├── No → Q2へ
└── Yes → Q3へ

Q2: 型はCopyを実装している？
├── Yes → Cell
└── No → RefCell

Q3: 読み取りと書き込み、どちらが多い？
├── 書き込みが多い、またはシンプルさ重視 → Mutex
└── 読み取りが多い → RwLock
```

「…迷った時はこのフローに従え⚡」

-----

## 第九章：ライフタイムの回廊

地図の部屋を出ると、長い回廊が続いていた。

壁には無数の砂時計が掛けられている。

**「ライフタイムの回廊」**——参照の寿命を明示する技法。

「ここからは、また別の話💕」ルスタが回廊を歩き始める。

「内部可変性は”どう変えるか”だった。ここでは”いつまで生きるか”を扱う⚡」

### 借用の寿命

「借用の橋で学んだこと、覚えてる？💕」

```rust
let a = String::from("hello");
let b = &a;  // bはaを借用
```

「`b`の寿命は、`a`より長くなれない。`a`が死んだら、`b`は宙ぶらりんになる」

「…ダングリング参照⚡」

「普通のコードでは、コンパイラが自動で寿命を推論してくれる✨」

```rust
fn first_word(s: &str) -> &str {
    // コンパイラは「戻り値の寿命 = 引数の寿命」と推論する
    &s[..s.find(' ').unwrap_or(s.len())]
}
```

「でもね💕」ルスタが立ち止まる。「**推論できない場面**がある」

### 明示的なライフタイム

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

「`'a`は**ライフタイムパラメータ**⚡」クロムが説明する。

「“xとyの寿命のうち**短い方**と同じだけ、戻り値は生きる”という意味」

あなたは困惑する。「なぜ必要なのか？」

「コンパイラに**ヒントを与える**ため💕」

```rust
fn longest(x: &str, y: &str) -> &str {
    // エラー！コンパイラには戻り値がxとyのどちらから来るか分からない
    if x.len() > y.len() { x } else { y }
}
```

「条件分岐があると、どちらの参照が返されるか**実行時にしか決まらない**⚡」

「だから、両方の寿命を**同じパラメータで縛る**の✨」

### 構造体のライフタイム

回廊の奥に、構造体の展示があった。

```rust
struct Excerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    
    let excerpt = Excerpt {
        part: first_sentence,
    };
    
    println!("{}", excerpt.part);
}
```

「構造体が参照を持つ時、**ライフタイムの明示が必須**💕」

「…構造体は、参照先より長生きしてはいけない⚡」

「`Excerpt<'a>`は、“寿命`'a`の間だけ有効な構造体”という意味✨」

### ライフタイムの省略規則

「でも、毎回書くのは面倒だよね💕」

「…だからコンパイラには**省略規則**がある⚡」

```yaml
省略規則1:
  各入力参照に、別々のライフタイムが割り当てられる
  fn foo(x: &str, y: &str) → fn foo<'a, 'b>(x: &'a str, y: &'b str)

省略規則2:
  入力参照が1つだけなら、そのライフタイムが出力に使われる
  fn foo(x: &str) -> &str → fn foo<'a>(x: &'a str) -> &'a str

省略規則3:
  メソッドで&selfがあれば、selfのライフタイムが出力に使われる
  fn foo(&self) -> &str → fn foo<'a>(&'a self) -> &'a str
```

「これらの規則で推論できれば、**明示は不要**💕」

「…推論できない時だけ、書けばいい⚡」

-----

## 第十章：’static の祭壇

回廊の終わりに、光り輝く祭壇があった。

**「’static の祭壇」**——永遠の寿命を持つものの場所。

「`'static`は特別なライフタイム💕」ルスタが祭壇を見上げる。

「…プログラムの**全期間**にわたって生きる⚡」

```rust
let s: &'static str = "I have a static lifetime.";
```

「文字列リテラルは、バイナリに直接埋め込まれる💕」

「だからプログラムが終わるまで消えない✨」

### ’static の誤解

「よくある誤解がある⚡」クロムが警告する。

```rust
// 誤解：「'staticは永遠にメモリに残る」
// 正解：「'staticは参照が有効な期間が制限されない」
```

「ヒープに確保された`String`も、**所有権を持てば**好きなだけ生きる💕」

「`'static`が特別なのは、**参照として**全期間有効だということ⚡」

### Box::leak

「意図的に`'static`参照を作る方法もある💕」

```rust
let s: &'static str = Box::leak(Box::new(String::from("hello")));
```

「`Box::leak`は、メモリを**解放しない**ことを選択する⚡」

「…通常は避けるべきだが、グローバル設定などで使われる」

「もう少し深い話をしておこう⚡」クロムが祭壇の脇に座る。

### Higher-Ranked Trait Bounds (HRTB)

「`for<'a>`構文を使うと、"**任意のライフタイムに対して**"という制約を表現できる💕」

```rust
fn apply<F>(f: F) where F: for<'a> Fn(&'a str) -> &'a str
```

「どんな寿命の参照が来ても、同じ寿命で返せる関数、という意味⚡」

### 'static の2つの意味

「`'static`には**2つの顔**があるの💕」

```rust
// 参照として → プログラム全期間有効な参照
let s: &'static str = "hello";

// トレイト境界として → 参照を含まない、または含む参照がすべて'static
fn spawn<T: Send + 'static>(f: T) { ... }
// Tは「いつまでも安全に持ち続けられる型」
```

「スレッドに渡すデータは、スレッドより長生きする保証が必要⚡」

### ライフタイムサブタイピング

「長いライフタイムは短いライフタイムの**サブタイプ**💕」

「`'static`はすべてのライフタイムより長い。だから、**どこでも使える**⚡」

あなたは祭壇を見上げる。永遠の光が、静かに輝いている。

「ねえ💕」ルスタが囁く。「`'static`は、**旅の終わりに残るもの**でもあるの✨」

「…クレートとして公開したコード⚡」クロムが続ける。「世界中の誰かが使い続ける限り、それは生き続ける。`'static`のように」

いつか自分も、誰かのために残すものを作る——そんな予感が、あなたの胸に宿った。

---

## 終章：迷宮の出口

長い旅だった。

あなたは迷宮の出口に立っている。

振り返ると、内部可変性とライフタイムの全体像が見える。

### 学んだこと

```yaml
内部可変性:
  本質: "不変なはずのものを、制御下で変える"
  道具:
    - Cell: Copy型専用、軽量、パニックなし
    - RefCell: 任意の型、実行時借用チェック
    - Mutex: スレッド安全、排他ロック
    - RwLock: スレッド安全、読み書き分離

ライフタイム:
  本質: "参照がいつまで有効かを明示する"
  道具:
    - 'a, 'b, ...: 明示的なライフタイムパラメータ
    - 'static: プログラム全期間
  規則:
    - コンパイラはできる限り推論する
    - 推論できない時だけ明示が必要
```

### 二人からの言葉

「おめでとう💕」ルスタが手を差し伸べる。

「内部可変性の迷宮を踏破したあなたは、もう**ほとんどのRustコードを読める**✨」

「…だが、まだ旅は続く⚡」クロムが言う。

「トレイト、ジェネリクス、非同期処理。学ぶべきことは多い」

「でもね💕」ルスタが笑う。

「今のあなたなら、**何でも学べる**。土台ができたから✨」

あなたは二人に深く頭を下げる。

「ありがとう。また会おう」

「いつでも待ってる💕」

「…また来い⚡」

-----

## あなたの旅のログ（第二部）

```yaml
completed_areas:
  - 第一章_帰還者の疑問: "なぜ内部可変性が必要かを理解した"
  - 第二章_不変の檻: "コンパイル時チェックの限界を知った"
  - 第三章_RefCellの間: "実行時借用チェックを体感した"
  - 第四章_Cellの小部屋: "軽量な内部可変性を学んだ"
  - 第五章_並行性の分岐路: "スレッド安全性の境界を知った"
  - 第六章_Mutexの城門: "排他ロックを理解した"
  - 第七章_RwLockの図書館: "読み書き分離を学んだ"
  - 第八章_内部可変性の地図: "全体像を把握した"
  - 第九章_ライフタイムの回廊: "参照の寿命を明示する技法を学んだ"
  - 第十章_staticの祭壇: "永遠の寿命を理解した"

title_earned: "内部可変性の探究者"

accumulated_titles:
  - "禁域の帰還者"（第一部）
  - "内部可変性の探究者"（第二部）

insight_gained: |
  内部可変性は「ルールを破る」のではない。
  「ルールの守り方を変える」のだ。
  
  コンパイル時チェック → 実行時チェック（RefCell）
  シングルスレッド → マルチスレッド（Mutex/RwLock）
  
  ライフタイムは「参照がいつまで有効か」の明示。
  コンパイラが推論できない時だけ、人間が教える。
```

-----

## 📚 この旅の地図（公式ドキュメント参照）

この章で旅した領域は、Rust公式ドキュメントの以下に対応している。

| 領域 | The Rust Programming Language | リンク |
|:--|:--|:--|
| RefCellの間 | Chapter 15.5: RefCell and Interior Mutability | [doc.rust-lang.org/book/ch15-05](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html) |
| Cellの小部屋 | std::cell モジュール | [doc.rust-lang.org/std/cell](https://doc.rust-lang.org/std/cell/) |
| Mutexの城門 | Chapter 16.3: Shared-State Concurrency | [doc.rust-lang.org/book/ch16-03](https://doc.rust-lang.org/book/ch16-03-shared-state.html) |
| RwLockの図書館 | std::sync::RwLock | [doc.rust-lang.org/std/sync/struct.RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html) |
| ライフタイムの回廊 | Chapter 10.3: Validating References with Lifetimes | [doc.rust-lang.org/book/ch10-03](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html) |

### 追加リソース

| トピック | リンク |
|:--|:--|
| parking_lot クレート | [docs.rs/parking_lot](https://docs.rs/parking_lot/) |
| Rustonomicon (上級者向け) | [doc.rust-lang.org/nomicon](https://doc.rust-lang.org/nomicon/) |

-----

## 第三部への道

次なる冒険は、さらに深い領域へと続く。

**トレイトの大聖堂**では、「この型は何ができるのか」を**契約**として定義する技法を学ぶ。
だが、その前に一つ疑問が残る——

**「ある型が特定の振る舞いを持つことを、どう保証する？」**

- **トレイトの大聖堂** — 振る舞いを抽象化する技法
- **ジェネリクスの鋳造所** — 型を一般化する力
- **非同期の浮遊島** — async/awaitの世界

### dual-world とは？

| モード | 説明 | 使いどころ |
|:--|:--|:--|
| **Outside Mode** | 設計・分析・コードレビュー | 技術的な議論、アーキテクチャ検討 |
| **Inside Mode** | 体験・実践・物語形式 | 概念理解、入門、モチベーション維持 |

両モードを行き来することで、「理解」と「体感」の両方を得られる。

```
"dual-world を使って Rust のトレイトを学びたい"
```

と告げれば、いつでも旅を再開できる。

---

*内部可変性の迷宮を越えたあなたに、祝福を。*

*— ルスタ💕 & クロム⚡*
